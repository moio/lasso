package grapher

import (
	"encoding/json"
	"log"
	"reflect"
	"runtime"
	"strings"

	llog "github.com/rancher/lasso/pkg/log"
)

type Event struct {
	Kind       string
	GVK        string
	WatchedGVK string
	Key        string
	Name       string
	StackTrace []string
	Function   string
}

type Model struct {
	Informers        map[string]bool
	Kinds            map[string]bool
	Functions        map[string]bool
	Enqueues         map[string]bool
	RelatedResources map[string]bool
	KindHandlerNames map[string]string

	InformerKeyCalls               map[string]map[string]int
	KindFunctionNameKeyCalls       map[string]map[string]map[string]map[string]int
	FunctionKindKeyEnqueues        map[string]map[string]map[string]int
	FunctionFunctionCalls          map[string]map[string]int
	KindRelatedResourceKeyEnqueues map[string]map[string]map[string]int
	RelatedResourceKindKeyEnqueues map[string]map[string]map[string]int
}

func Record(obj Event) {
	bytes, err := json.Marshal(obj)
	if err != nil {
		llog.Errorf("Error while marshalling trace object %v", err)
		return
	}
	log.Printf("TRACE: " + string(bytes))
}

func StackTrace() []string {
	pc := make([]uintptr, 100)
	n := runtime.Callers(2, pc)
	pc = pc[:n] // pass only valid pcs to runtime.CallersFrames
	frames := runtime.CallersFrames(pc)

	// Loop to get frames.
	// A fixed number of PCs can expand to an indefinite number of Frames.
	// Frames are processed from the innermost to the outermost caller
	var result []string
	for {
		frame, more := frames.Next()

		if !more {
			break
		}

		result = append(result, frame.Function)
	}

	return result
}

func HandlerFuncName(f any) string {
	raw := runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()
	// FuncForPC might return function names in the form Name-fm, where the -fm part is autogenerated
	// by the compiler for closures, that can safely be removed
	result := strings.Split(raw, "-")[0]
	return result
}
